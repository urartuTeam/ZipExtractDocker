
  // Получить должности с информацией об отделах и родительских должностях
  app.get('/api/positions/with-departments', async (req: Request, res: Response) => {
    try {
      // Получаем все должности, отделы и связи
      const positions = await storage.getAllPositions();
      const departments = await storage.getAllDepartments();
      const positionDepartments = await storage.getAllPositionDepartments();
      const positionPositions = await storage.getAllPositionPositions();

      // Создаем обогащенный список должностей с отделами и связями
      const positionsWithDepts = positions.map((position) => {
        // Находим все связи position_department для данной должности
        const links = positionDepartments.filter(
            (pd) => pd.position_id === position.position_id,
        );

        // Находим соответствующие отделы из связей в таблице position_department
        const linkedDepartments: any[] = [];

        // Для каждой связи из position_department обрабатываем департамент отдельно
        for (const link of links) {
          // Находим информацию об отделе
          const dept = departments.find(
              (d) => d.department_id === link.department_id,
          );

          if (!dept) continue;

          // Базовая информация о связи с отделом (без родительских должностей)
          const baseDeptInfo = {
            position_link_id: link.position_link_id,
            department_id: link.department_id,
            department_name: dept?.name || "Неизвестный отдел",
            sort: link.sort,
            vacancies: link.vacancies || 0,
          };

          // Теперь ищем все родительские позиции для этой должности в этом отделе
          const parentsForDept = positionPositions.filter(
              (pp) =>
                  pp.position_id === position.position_id &&
                  pp.department_id === link.department_id
          );

          // Если нет родительских позиций, добавляем только базовую связь с отделом
          if (parentsForDept.length === 0) {
            linkedDepartments.push({
              ...baseDeptInfo,
              parent_positions: [],
              parent_position: null,
              position_position_id: null,
              group_key: `null_${link.department_id}` // Ключ для группировки по отделу без родителя
            });
          } else {
            // Для каждой родительской должности создаем отдельную связь
            for (const parentRelation of parentsForDept) {
              const parentPosition = positions.find(
                  (p) => p.position_id === parentRelation.parent_position_id,
              );

              if (parentPosition) {
                // Создаем уникальный ключ группировки для пары (родительская должность + отдел)
                const groupKey = `${parentPosition.position_id}_${link.department_id}`;

                linkedDepartments.push({
                  ...baseDeptInfo,
                  parent_position: {
                    position_id: parentPosition.position_id,
                    name: parentPosition.name,
                  },
                  parent_positions: [{ // Для обратной совместимости
                    position_id: parentPosition.position_id,
                    name: parentPosition.name,
                  }],
                  position_position_id: parentRelation.position_relation_id, // ID связи для удаления
                  group_key: groupKey // Ключ для группировки
                });
              }
            }
          }
        }

        // Добавляем информацию о родительских должностях из position_position
        // Это информация о том, кому подчиняется эта должность
        const parentRelations = positionPositions.filter(
            (pp) => pp.position_id === position.position_id,
        );
        const parentPositionsInfo = parentRelations
            .map((relation) => {
              const parentPosition = positions.find(
                  (p) => p.position_id === relation.parent_position_id,
              );
              if (parentPosition) {
                return {
                  position_id: parentPosition.position_id,
                  name: parentPosition.name,
                  department_id: relation.department_id,
                };
              }
              return null;
            })
            .filter(Boolean);

        // Получаем информацию о подчиненных должностях
        const childrenRelations = positionPositions.filter(
            (pp) => pp.parent_position_id === position.position_id,
        );
        const childrenPositionsInfo = childrenRelations
            .map((relation) => {
              const childPosition = positions.find(
                  (p) => p.position_id === relation.position_id,
              );
              if (childPosition) {
                return {
                  position_id: childPosition.position_id,
                  name: childPosition.name,
                  department_id: relation.department_id,
                };
              }
              return null;
            })
            .filter(Boolean);

        return {
          ...position,
          departments: linkedDepartments,
          parent_positions: parentPositionsInfo,
          children_positions: childrenPositionsInfo,
          // Добавляем флаг, указывающий, является ли должность подчиненной
          is_subordinate: parentRelations.length > 0,
        };
      });

      // Выведем первую должность в консоль для отладки
      if (positionsWithDepts.length > 0) {
        console.log("Пример обработанной должности:",
            JSON.stringify({
              position_id: positionsWithDepts[0].position_id,
              name: positionsWithDepts[0].name,
              departments: positionsWithDepts[0].departments
            }, null, 2)
        );
      }

      res.json({ status: 'success', data: positionsWithDepts });
    } catch (error) {
      console.log( error);
      res.status(500).json({
        status: 'error',
        message: 'Ошибка сервера при получении должностей с отделами'
      });
    }
  });